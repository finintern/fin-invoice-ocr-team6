#!/usr/bin/env python3
"""
Authentication Penetration Testing Script for OCR Group 6 API

This script tests security aspects of the authentication mechanisms:
1. Client Credential Manipulation Testing
2. Token Security Testing
3. Authentication Bypass Testing
4. Credential Leakage Testing

API Endpoints:
- Base URL: http://localhost:3000
- Invoice API: http://localhost:3000/api/invoices
- Purchase Order API: http://localhost:3000/api/purchase-orders
"""

import requests
import os
import time
import json
import argparse
import uuid
from concurrent.futures import ThreadPoolExecutor, as_completed
from colorama import Fore, Style, init

# Define API constants
DEFAULT_BASE_URL = "http://localhost:3000"
INVOICE_API_PATH = "/api/invoices"
PO_API_PATH = "/api/purchase-orders"

# Initialize colorama for cross-platform colored terminal output
init()

class AuthenticationPenTester:
    def __init__(self, base_url=DEFAULT_BASE_URL):
        self.base_url = base_url
        self.invoice_endpoint = f"{self.base_url}{INVOICE_API_PATH}"
        self.po_endpoint = f"{self.base_url}{PO_API_PATH}"
        self.vulnerabilities_found = []
        self.success_count = 0
        self.failure_count = 0
        self.test_count = 0
        
    def run_tests(self):
        """Run all authentication penetration tests"""
        print(f"{Fore.CYAN}ðŸ”’ AUTHENTICATION PENETRATION TESTING - OCR-Group 6-API ðŸ”’{Style.RESET_ALL}")
        print("=" * 70)
        
        start_time = time.time()
        
        # Run the different test categories
        self.test_missing_credentials()
        self.test_credential_manipulation()
        self.test_credential_leakage()
        
        duration = time.time() - start_time
        
        # Print test report
        self.print_report(duration)
    
    def test_missing_credentials(self):
        """Test API endpoints with missing authentication credentials"""
        print(f"\n{Fore.BLUE}[INFO] Testing missing authentication credentials...{Style.RESET_ALL}")
        
        # Test scenarios
        scenarios = [
            {"desc": "No credentials", "headers": {}},
            {"desc": "Missing client_secret", "headers": {"client_id": "test"}},
            {"desc": "Missing client_id", "headers": {"client_secret": "test"}},
            {"desc": "Empty client_id", "headers": {"client_id": "", "client_secret": "test"}},
            {"desc": "Empty client_secret", "headers": {"client_id": "test", "client_secret": ""}}
        ]
        
        for scenario in scenarios:
            self.test_count += 1
            try:
                response = requests.get(f"{self.invoice_endpoint}/123", headers=scenario["headers"])
                
                if response.status_code == 401:
                    print(f"{Fore.GREEN}[PASS] {scenario['desc']} - Properly rejected with 401{Style.RESET_ALL}")
                    self.success_count += 1
                else:
                    print(f"{Fore.RED}[FAIL] {scenario['desc']} - Got {response.status_code} instead of 401{Style.RESET_ALL}")
                    self.vulnerabilities_found.append(f"Missing credentials test failed: {scenario['desc']}")
                    self.failure_count += 1
                    
            except Exception as e:
                print(f"{Fore.YELLOW}[ERROR] Test failed with exception: {str(e)}{Style.RESET_ALL}")

    def test_credential_manipulation(self):
        """Test for SQL injection and other manipulation in client credentials"""
        print(f"\n{Fore.BLUE}[INFO] Testing credential manipulation vulnerabilities...{Style.RESET_ALL}")
        
        # Test payloads
        payloads = [
            {"desc": "SQL Injection 1", "client_id": "' OR 1=1--", "client_secret": "test"},
            {"desc": "SQL Injection 2", "client_id": "test", "client_secret": "' OR 1=1--"},
            {"desc": "SQL Injection 3", "client_id": "' UNION SELECT * FROM partner--", "client_secret": "test"},
            {"desc": "NoSQL Injection", "client_id": '{"$gt":""}', "client_secret": "test"},
            {"desc": "Long String", "client_id": "A" * 1000, "client_secret": "test"}
        ]
        
        for payload in payloads:
            self.test_count += 1
            try:
                headers = {
                    "client_id": payload["client_id"],
                    "client_secret": payload["client_secret"]
                }
                
                response = requests.get(f"{self.invoice_endpoint}/123", headers=headers)
                
                if response.status_code == 401:
                    print(f"{Fore.GREEN}[PASS] {payload['desc']} - Properly rejected with 401{Style.RESET_ALL}")
                    self.success_count += 1
                else:
                    print(f"{Fore.RED}[FAIL] {payload['desc']} - Got {response.status_code}, potential vulnerability{Style.RESET_ALL}")
                    self.vulnerabilities_found.append(f"Credential manipulation: {payload['desc']} got {response.status_code}")
                    self.failure_count += 1
                    
            except requests.exceptions.InvalidHeader:
                print(f"{Fore.GREEN}[PASS] {payload['desc']} - Header injection attempt was blocked{Style.RESET_ALL}")
                self.success_count += 1
            except Exception as e:
                print(f"{Fore.YELLOW}[ERROR] Test failed with exception: {str(e)}{Style.RESET_ALL}")
            
    def test_credential_leakage(self):
        """Test for credential leakage in error messages or responses"""
        print(f"\n{Fore.BLUE}[INFO] Testing for credential leakage in responses...{Style.RESET_ALL}")
        self.test_count += 1
        
        # Send a request with invalid credentials
        headers = {
            "client_id": "test_invalid_id",
            "client_secret": "test_invalid_secret"
        }
        
        try:
            response = requests.get(f"{self.invoice_endpoint}/123", headers=headers)
            
            # Check if the response body contains any of our credentials
            response_text = response.text.lower()
            leakage_detected = False
            
            if "test_invalid_id" in response_text or "test_invalid_secret" in response_text:
                print(f"{Fore.RED}[FAIL] Credential leakage detected in error responses{Style.RESET_ALL}")
                self.vulnerabilities_found.append("Credentials are leaked in error responses")
                leakage_detected = True
                self.failure_count += 1
                
            if not leakage_detected:
                print(f"{Fore.GREEN}[PASS] No credential leakage detected in error responses{Style.RESET_ALL}")
                self.success_count += 1
                
        except Exception as e:
            print(f"{Fore.YELLOW}[ERROR] Test failed with exception: {str(e)}{Style.RESET_ALL}")
    
    def print_report(self, duration):
        """Print penetration test report"""
        print("\n" + "=" * 70)
        print(f"{Fore.CYAN}ðŸ“Š AUTHENTICATION PENETRATION TEST REPORT ðŸ“Š{Style.RESET_ALL}")
        print("=" * 70)
        
        print(f"Test Duration: {duration:.2f} seconds\n")
        
        print(f"{Fore.CYAN}TEST STATISTICS:{Style.RESET_ALL}")
        print(f"Total Tests: {self.test_count}")
        print(f"Passed: {self.success_count}")
        print(f"Failed: {self.failure_count}")
        
        print(f"\n{Fore.CYAN}SECURITY FINDINGS:{Style.RESET_ALL}")
        
        if not self.vulnerabilities_found:
            print(f"{Fore.GREEN}No vulnerabilities found! Authentication appears to be secure.{Style.RESET_ALL}")
        else:
            print(f"{Fore.RED}Vulnerabilities found: {len(self.vulnerabilities_found)}{Style.RESET_ALL}")
            for i, vuln in enumerate(self.vulnerabilities_found, 1):
                print(f"{Fore.RED}{i}. {vuln}{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}RECOMMENDATIONS:{Style.RESET_ALL}")
        
        if not self.vulnerabilities_found:
            print("1. Continue monitoring authentication security")
            print("2. Perform regular security assessments")
            print("3. Consider implementing multi-factor authentication where appropriate")
        else:
            if "Credentials are leaked in error responses" in self.vulnerabilities_found:
                print("1. Use generic error messages that don't reveal credential information")
            
            # Add any other vulnerability-specific recommendations here
        
        print("\n" + "=" * 70)
        print(f"{Fore.YELLOW}DISCLAIMER: This penetration test was performed in a controlled environment")
        print(f"with proper authorization. Never test applications without permission.{Style.RESET_ALL}")
        print("=" * 70)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Authentication Penetration Testing Tool for OCR Group 6 API")
    parser.add_argument("-u", "--url", help="Base URL of the API (default: http://localhost:3000)", default="http://localhost:3000")
    parser.add_argument("-v", "--verbose", help="Enable verbose output", action="store_true")
    
    args = parser.parse_args()
    
    tester = AuthenticationPenTester(args.url)
    tester.run_tests()