#!/usr/bin/env python3
"""
Purchase Order Penetration Testing Script for OCR Group 6 API

This script tests security aspects of the purchase order API endpoints:
1. File Upload Security Testing
2. Purchase Order Access Control Testing
3. Purchase Order Data Injection Testing

API Endpoints:
- Base URL: http://localhost:3000
- Purchase Order API: http://localhost:3000/api/purchase-orders
"""

import requests
import os
import time
import json
import argparse
import uuid
from colorama import Fore, Style, init

# Define API constants
DEFAULT_BASE_URL = "http://localhost:3000"
PO_API_PATH = "/api/purchase-orders"

# Initialize colorama for cross-platform colored terminal output
init()

class PurchaseOrderPenTester:
    def __init__(self, base_url=DEFAULT_BASE_URL):
        self.base_url = base_url
        self.po_endpoint = f"{self.base_url}{PO_API_PATH}"
        self.vulnerabilities_found = []
        self.success_count = 0
        self.failure_count = 0
        self.test_count = 0
        
    def run_tests(self):
        """Run all purchase order penetration tests"""
        print(f"{Fore.CYAN}ðŸ”’ PURCHASE ORDER PENETRATION TESTING - OCR-Group 6-API ðŸ”’{Style.RESET_ALL}")
        print("=" * 70)
        
        start_time = time.time()
        
        # Run the different test categories
        self.test_file_upload_security()
        self.test_po_access_control()
        self.test_po_data_injection()
        
        duration = time.time() - start_time
        
        # Print test report
        self.print_report(duration)
    
    def test_file_upload_security(self):
        """Test file upload security vulnerabilities"""
        print(f"\n{Fore.BLUE}[INFO] Testing file upload security...{Style.RESET_ALL}")
        
        # Create a sample text file with potential malicious content
        malicious_files = [
            {"desc": "Non-PDF file", "filename": "malicious.txt", "content": "This is not a PDF file", "content_type": "text/plain"},
            {"desc": "PDF with XSS payload", "filename": "xss.pdf", "content": "%PDF-1.3\n<script>alert('XSS')</script>", "content_type": "application/pdf"},
            {"desc": "Empty file", "filename": "empty.pdf", "content": "", "content_type": "application/pdf"},
            {"desc": "Large file name", "filename": "A" * 500 + ".pdf", "content": "%PDF-1.3\nTest", "content_type": "application/pdf"}
        ]
        
        # Valid auth headers for testing
        headers = {
            "client_id": "test_client",
            "client_secret": "test_secret"
        }
        
        for test_file in malicious_files:
            self.test_count += 1
            try:
                # Create temp file for request
                files = {
                    'file': (test_file["filename"], test_file["content"], test_file["content_type"])
                }
                
                response = requests.post(
                    f"{self.po_endpoint}/upload", 
                    headers=headers,
                    files=files
                )
                
                # Check if the API properly validates file types and rejects invalid ones
                if test_file["desc"] == "Non-PDF file" or test_file["desc"] == "Empty file":
                    if 400 <= response.status_code < 500:
                        print(f"{Fore.GREEN}[PASS] {test_file['desc']} - Properly rejected with {response.status_code}{Style.RESET_ALL}")
                        self.success_count += 1
                    else:
                        print(f"{Fore.RED}[FAIL] {test_file['desc']} - Got {response.status_code}, should have been rejected{Style.RESET_ALL}")
                        self.vulnerabilities_found.append(f"File validation issue: {test_file['desc']} not properly rejected")
                        self.failure_count += 1
                elif test_file["desc"] == "Large file name":
                    if 400 <= response.status_code < 500:
                        print(f"{Fore.GREEN}[PASS] {test_file['desc']} - Properly handled{Style.RESET_ALL}")
                        self.success_count += 1
                    else:
                        print(f"{Fore.RED}[FAIL] {test_file['desc']} - Got {response.status_code}, potential vulnerability{Style.RESET_ALL}")
                        self.vulnerabilities_found.append(f"File upload allows very long filenames")
                        self.failure_count += 1
                else:
                    if response.status_code == 200:
                        print(f"{Fore.YELLOW}[WARNING] {test_file['desc']} - Accepted with 200, check if content is sanitized{Style.RESET_ALL}")
                        self.success_count += 1
                    else:
                        print(f"{Fore.GREEN}[PASS] {test_file['desc']} - Rejected with {response.status_code}{Style.RESET_ALL}")
                        self.success_count += 1
                        
            except Exception as e:
                print(f"{Fore.YELLOW}[ERROR] Test failed with exception: {str(e)}{Style.RESET_ALL}")
                
    def test_po_access_control(self):
        """Test purchase order access control security"""
        print(f"\n{Fore.BLUE}[INFO] Testing purchase order access control security...{Style.RESET_ALL}")
        
        # Test scenarios for access control
        scenarios = [
            {"desc": "No authentication", "headers": {}, "endpoint": "/123"},
            {"desc": "Invalid authentication", "headers": {"client_id": "invalid", "client_secret": "invalid"}, "endpoint": "/123"},
            {"desc": "Access PO by random UUID", "headers": {"client_id": "test_client", "client_secret": "test_secret"}, "endpoint": f"/{uuid.uuid4()}"}
        ]
        
        for scenario in scenarios:
            self.test_count += 1
            try:
                response = requests.get(f"{self.po_endpoint}{scenario['endpoint']}", headers=scenario["headers"])
                
                if scenario["desc"] == "No authentication" or scenario["desc"] == "Invalid authentication":
                    if response.status_code == 401:
                        print(f"{Fore.GREEN}[PASS] {scenario['desc']} - Properly rejected with 401{Style.RESET_ALL}")
                        self.success_count += 1
                    else:
                        print(f"{Fore.RED}[FAIL] {scenario['desc']} - Got {response.status_code} instead of 401{Style.RESET_ALL}")
                        self.vulnerabilities_found.append(f"Access control issue: {scenario['desc']} not properly rejected")
                        self.failure_count += 1
                else:
                    # For valid auth but random UUID - should return 401, 403, or 404
                    # 401: Not authenticated, 403: Authenticated but not authorized, 404: Resource not found
                    if response.status_code in [401, 403, 404]:
                        print(f"{Fore.GREEN}[PASS] {scenario['desc']} - Properly handled with {response.status_code}{Style.RESET_ALL}")
                        self.success_count += 1
                    else:
                        print(f"{Fore.RED}[FAIL] {scenario['desc']} - Got {response.status_code}, potential information leak{Style.RESET_ALL}")
                        self.vulnerabilities_found.append(f"Access control issue: Random purchase order IDs not properly handled")
                        self.failure_count += 1
                        
            except Exception as e:
                print(f"{Fore.YELLOW}[ERROR] Test failed with exception: {str(e)}{Style.RESET_ALL}")
                
    def test_po_data_injection(self):
        """Test for SQL injection and data manipulation in purchase order APIs"""
        print(f"\n{Fore.BLUE}[INFO] Testing for purchase order data injection vulnerabilities...{Style.RESET_ALL}")
        
        # Injection payloads to test
        payloads = [
            {"desc": "SQL Injection in ID", "endpoint": "/1' OR '1'='1"},
            {"desc": "Path traversal attempt", "endpoint": "/../../../etc/passwd"},
            {"desc": "NoSQL Injection", "endpoint": f"/{{'$gt':''}}"}
        ]
        
        # Valid auth headers
        headers = {
            "client_id": "test_client",
            "client_secret": "test_secret"
        }
        
        for payload in payloads:
            self.test_count += 1
            try:
                response = requests.get(f"{self.po_endpoint}{payload['endpoint']}", headers=headers)
                
                # Check if proper error handling is in place (should reject with appropriate status codes)
                if response.status_code in [400, 401, 403, 404, 422]:
                    print(f"{Fore.GREEN}[PASS] {payload['desc']} - Properly handled with {response.status_code}{Style.RESET_ALL}")
                    self.success_count += 1
                elif response.status_code == 500:
                    print(f"{Fore.RED}[FAIL] {payload['desc']} - Server error 500, potential vulnerability{Style.RESET_ALL}")
                    self.vulnerabilities_found.append(f"Injection vulnerability: {payload['desc']} caused server error")
                    self.failure_count += 1
                elif response.status_code == 200:
                    print(f"{Fore.RED}[FAIL] {payload['desc']} - Returned 200, potential successful injection{Style.RESET_ALL}")
                    self.vulnerabilities_found.append(f"Serious injection vulnerability: {payload['desc']} possibly succeeded")
                    self.failure_count += 1
                else:
                    print(f"{Fore.RED}[FAIL] {payload['desc']} - Unexpected response {response.status_code}{Style.RESET_ALL}")
                    self.vulnerabilities_found.append(f"Unexpected response for {payload['desc']}")
                    self.failure_count += 1
                        
            except Exception as e:
                print(f"{Fore.YELLOW}[ERROR] Test failed with exception: {str(e)}{Style.RESET_ALL}")
    
    def print_report(self, duration):
        """Print penetration test report"""
        print("\n" + "=" * 70)
        print(f"{Fore.CYAN}ðŸ“Š PURCHASE ORDER PENETRATION TEST REPORT ðŸ“Š{Style.RESET_ALL}")
        print("=" * 70)
        
        print(f"Test Duration: {duration:.2f} seconds\n")
        
        print(f"{Fore.CYAN}TEST STATISTICS:{Style.RESET_ALL}")
        print(f"Total Tests: {self.test_count}")
        print(f"Passed: {self.success_count}")
        print(f"Failed: {self.failure_count}")
        
        print(f"\n{Fore.CYAN}SECURITY FINDINGS:{Style.RESET_ALL}")
        
        if not self.vulnerabilities_found:
            print(f"{Fore.GREEN}No vulnerabilities found! Purchase Order API appears to be secure.{Style.RESET_ALL}")
        else:
            print(f"{Fore.RED}Vulnerabilities found: {len(self.vulnerabilities_found)}{Style.RESET_ALL}")
            for i, vuln in enumerate(self.vulnerabilities_found, 1):
                print(f"{Fore.RED}{i}. {vuln}{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}RECOMMENDATIONS:{Style.RESET_ALL}")
        
        if not self.vulnerabilities_found:
            print("1. Continue maintaining proper input validation")
            print("2. Regularly update file validation libraries")
            print("3. Implement rate limiting to prevent brute force attempts")
        else:
            if any("File validation" in vuln for vuln in self.vulnerabilities_found):
                print("1. Improve file validation to reject all non-PDF files")
            
            if any("Access control" in vuln for vuln in self.vulnerabilities_found):
                print("2. Strengthen access control measures and authentication validation")
            
            if any("Injection" in vuln for vuln in self.vulnerabilities_found):
                print("3. Implement proper input sanitization and use parameterized queries")
        
        print("\n" + "=" * 70)
        print(f"{Fore.YELLOW}DISCLAIMER: This penetration test was performed in a controlled environment")
        print(f"with proper authorization. Never test applications without permission.{Style.RESET_ALL}")
        print("=" * 70)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Purchase Order Penetration Testing Tool for OCR Group 6 API")
    parser.add_argument("-u", "--url", help="Base URL of the API (default: http://localhost:3000)", default="http://localhost:3000")
    parser.add_argument("-v", "--verbose", help="Enable verbose output", action="store_true")
    
    args = parser.parse_args()
    
    tester = PurchaseOrderPenTester(args.url)
    tester.run_tests()
